using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;
using System.Threading;
using WinRTWrapper.CodeAnalysis;
using WinRTWrapper.SourceGenerators.Models;

namespace WinRTWrapper.SourceGenerators
{
    [Generator(LanguageNames.CSharp)]
    public sealed partial class WinRTWrapperGenerator : IIncrementalGenerator
    {
        private const string namespaceName = $"{nameof(WinRTWrapper)}.{nameof(CodeAnalysis)}";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(EmitPostGeneratedType);

            IncrementalValuesProvider<WrapperType?> wrapperTypes =
                context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{namespaceName}.{nameof(GenerateWinRTWrapperAttribute)}",
                    static (x, _) => x is ClassDeclarationSyntax,
                    GetWrapperType)
                .Where(static x => x != null);

            context.RegisterSourceOutput(wrapperTypes, EmitGeneratedType);
        }

        private static WrapperType? GetWrapperType(GeneratorAttributeSyntaxContext context, CancellationToken token)
        {
            token.ThrowIfCancellationRequested();
            if (context is { TargetSymbol: INamedTypeSymbol symbol, Attributes: [{ ConstructorArguments: [{ Kind: TypedConstantKind.Type, Value: INamedTypeSymbol target }] }] })
            {
                return new WrapperType(symbol, target);
            }
            return null;
        }

        private static void EmitGeneratedType(SourceProductionContext context, WrapperType? source)
        {
            (INamedTypeSymbol symbol, INamedTypeSymbol target) = source!;
            StringBuilder builder = InitBuilder(source);
            bool? needConstructor = null;
            foreach (ISymbol member in target.GetMembers())
            {
                switch (member)
                {
                    case not { DeclaredAccessibility: Accessibility.Public }:
                        continue;
                    case IMethodSymbol method:
                        _ = AddMethod(source, method, builder, ref needConstructor);
                        break;
                    case IPropertySymbol property:
                        _ = AddProperty(source, property, builder);
                        break;
                    case IEventSymbol @event:
                        _ = AddEvent(source, @event, builder);
                        break;
                }
            }

            if (needConstructor == true)
            {
                _ = builder.Append(
                    $$"""
                            /// Initializes a new instance of the <see cref="{{symbol.GetDocumentationCommentId()}}"/> class.
                            internal {{symbol.Name}}() { }
                    """);
            }

            string generatedCode =
                $$"""
                // <auto-generated/>
                #pragma warning disable
                namespace {{symbol.ContainingNamespace.ToDisplayString()}}
                {
                    /// <inheritdoc cref="{{target.GetDocumentationCommentId()}}"/>
                    public {{(symbol.IsStatic ? "static" : "sealed")}} partial class {{symbol.Name}}
                    {
                {{builder.ToString().TrimEnd()}}
                    }
                }
                """;
            context.AddSource($"{symbol.Name}.g.cs", generatedCode);
        }
    }
}
